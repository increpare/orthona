#!/usr/bin/env node

var emoji = require('node-emoji');



var fs 				= require('fs')
var glob 			= require('./js/app/orthoGlobals')
var lib 			= require('./js/orthoLib')
var svgRender 		= require("./js/orthoTopology")
var log=console.log

if (process.argv.length===2){
	console.log("USAGE: printOrtho [-ascii] [-noLines] FILENAME");
	return;
}

var asciiCharacters=false;
var skeleton=false;
var inputFileName=""
for (var i=2;i<process.argv.length;i++){
	var t = process.argv[i];
	if (t==="-ascii"){
		asciiCharacters=true;
	} else if (t==="-noLines"){
		skeleton=true;
	} else if (inputFileName===""){
		inputFileName=t;
	} else {
		console.log("Too many arguments. Unexpected argument \""+t+"\".");		
	}
}

var symbols = [
	"â– ","â–¼","âŒ”","â—‹","â€¢",
	"âŠš","â—‡","â–³","â–¡","â˜†",
	"â™§","â§‰","ðŸ”’","á—¡","ðŸ‘‘",
	"ðŸ‘","ðŸ‘„","ðŸ‘†","ðŸ‘‚","ðŸ´",
	"ðŸ’­","ðŸ‘ƒ","âŒ›ï¸","âŠ¿","ðŸŒ",
	"â¬¡","â¬‡","âŒ‘","Î»","âœ™",
	"â˜¯","â–£","â¨¸","ðŸŒ€","ðŸ“„"];

if (asciiCharacters){
	symbols = "1234.abcdefghijklmnopqrstuvwxyABCDE";
}

if (inputFileName==="")
{
	console.log("need to supply input file");
}

lib.loadFile(inputFileName);

var bounds = lib.getBounds();
var height = bounds[1]-bounds[0]+1
var width = bounds[3]-bounds[2]+1

var offsetX=bounds[2]
var offsetY=bounds[0]



if (skeleton){
	//GRID INDICES ARE Y,X
	var grid = []
	for (var j=0;j<height;j++){
		var row = []
		for (var i=0;i<width;i++){
			row.push(" ")
		}
		grid.push(row)
	}

	for (var i=0;i<page.elements.length;i++){
		var e = page.elements[i]
		var ex = e[0]-offsetX
		var ey = e[1]-offsetY
		var es = symbols[e[2]]
		grid[ey][ex]=es
	}
		
	var ans=""
	for (var j=0;j<height;j++){
		for (var i=0;i<width;i++){
			ans+=grid[j][i]
		}
		ans+="\n"
	}
	console.log(ans)
	return;
}

//GRID INDICES ARE Y,X
var grid = []
for (var j=0;j<2*height+1;j++){
	var row = []
	for (var i=0;i<2*width+1;i++){
		row.push(" ")
	}
	grid.push(row)
}

function LineAtPoint(p){
	for (var i=0;i<page.lines.length;i++){
		var l = page.lines[i];
		if (lib.PointOnLine(p,l)){		
			return  l;
		}
	}
	return null;
}


var lines = [" -/|\\"," â€¦â‹°â‹®â‹±"];

for (var i=0;i<width;i++){
	for (var j=0;j<height;j++){
		var p = [i+offsetX,j+offsetY]
		var l = LineAtPoint(p);
		if (l!==null){
			var ld1=lib.LineDirection(l);
			grid[2*j+1][2*i+1]=lines[l[4]===1?1:0][Math.abs(ld1)];
			
			//for each cell, check 9 points for line drawing
			for (var mi=-1;mi<=1;mi++){
				for (var mj=-1;mj<=1;mj++){
					if (mi===0&&mj===0){
						continue;
					}
					var p_out=[p[0]+mi,p[1]+mj]
					if (lib.Connection(p,p_out,page.lines)[0]){
						var l2 = LineAtPoint(p_out);
						if (l2!==null){
							var l_dir = lib.LineDirection(l2);
							var l_vec = lib.axes[l_dir];
							if ((l_vec[0]===mi&&l_vec[1]===mj)||(l_vec[0]===-mi&&l_vec[1]===-mj)){
								l_dir=Math.abs(l_dir);								
								grid[2*j+1+mj][2*i+1+mi]=lines[l2[4]===1?1:0][Math.abs(l_dir)];
							}
						}
					}
				}
			}
		}
	}
}


for (var i=0;i<page.elements.length;i++){
	var e = page.elements[i]
	var ex = e[0]-offsetX
	var ey = e[1]-offsetY
	var es = symbols[e[2]]
	grid[2*ey+1][2*ex+1]=es
}

var ans=""
for (var j=0;j<2*height+1;j++){
	for (var i=0;i<2*width+1;i++){
		ans+=grid[j][i]
	}
	ans+="\n"
}
console.log(ans)